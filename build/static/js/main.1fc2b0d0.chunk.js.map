{"version":3,"sources":["services/index.js","App.js","hooks/useIsElementVisible.js","index.js"],"names":["fetchTodos","page","Promise","resolve","setTimeout","initial","final","filtered","mock","filter","el","index","itens","totalPages","length","App","lastRef","useRef","useState","isLoading","setIsLoading","todos","setTodos","isLastVisible","isVisible","setIsVisible","callback","entry","isIntersecting","useEffect","watch","IntersectionObserver","observe","unobserve","useIsElementVisible","current","getMoreTodos","a","newTodos","prev","concat","className","map","title","key","ref","ReactDOM","render","document","getElementById"],"mappings":"6PAIaA,EAAa,SAACC,GACzB,OAAO,IAAIC,SAAQ,SAACC,GAClBC,YAAW,WACT,IAAMC,EALI,GAKgBJ,EALhB,GAMJK,EANI,GAMcL,EAElBM,EAAWC,EAAKC,QAAO,SAACC,EAAIC,GAChC,OAAOA,EAAQN,GAAWM,GAASL,KAGrC,OAAOH,EAAQ,CACbS,MAAOL,EACPN,OACAY,WAAYL,EAAKM,OAfT,OACA,SCCD,SAASC,IACtB,IAAMC,EAAUC,iBAAO,MADK,EAEMC,oBAAS,GAFf,mBAErBC,EAFqB,KAEVC,EAFU,OAGFF,mBAAS,CACjCN,MAAO,GACPX,KAAM,EACNY,WAAY,IANc,mBAGrBQ,EAHqB,KAGdC,EAHc,KAQtBC,ECVO,SAACb,GAAQ,IAAD,EACaQ,oBAAS,GADtB,mBACdM,EADc,KACHC,EADG,KAEfC,EAAW,SAAC,GAAa,IAAZC,EAAW,oBAC5BF,EAAaE,EAAMC,iBAWrB,OARAC,qBAAU,WACR,IAAMC,EAAQ,IAAIC,qBAAqBL,GACvC,GAAIhB,EAEF,OADAoB,EAAME,QAAQtB,GACP,kBAAMoB,EAAMG,UAAUvB,MAE9B,CAACA,IAEGc,KAAed,EDJAwB,CAAoBlB,EAAQmB,SAElDN,qBAAU,WACRO,EAAaf,EAAMpB,KAAO,KACzB,IAEH4B,qBAAU,WACJN,GACFa,EAAaf,EAAMpB,KAAO,KAE3B,CAACsB,IAEJ,IAAMa,EAAY,uCAAG,WAAOnC,GAAP,eAAAoC,EAAA,sEAEjBjB,GAAa,GAFI,SAGMpB,EAAWC,GAHjB,OAGXqC,EAHW,OAIjBhB,GAAS,SAACiB,GAAD,sBACJD,EADI,CAEP1B,MAAO2B,EAAK3B,MAAM4B,OAAOF,EAAS1B,YAEpCQ,GAAa,GARI,yGAAH,sDAYlB,OACE,yBAAKqB,UAAU,aACb,wBAAIA,UAAU,SAAd,sBACCpB,EAAMT,MAAM8B,KAAI,WAAY/B,GAAW,IAApBgC,EAAmB,EAAnBA,MAClB,OACE,yBAAKF,UAAU,WAAWG,IAAKjC,GAC7B,2BAAIgC,SAIPtB,EAAMT,MAAME,QAAUO,EAAMpB,KAAOoB,EAAMR,YAC1C,yBAAKgC,IAAK7B,IAEXG,GAAa,uBAAGsB,UAAU,WAAb,eE5CpBK,IAASC,OAAO,kBAAChC,EAAD,MAASiC,SAASC,eAAe,U","file":"static/js/main.1fc2b0d0.chunk.js","sourcesContent":["import mock from \"./mock.json\";\n\nconst perPage = 10;\nconst timeout = 2000;\nexport const fetchTodos = (page) => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      const initial = perPage * page - perPage;\n      const final = perPage * page;\n\n      const filtered = mock.filter((el, index) => {\n        return index > initial && index <= final;\n      });\n\n      return resolve({\n        itens: filtered,\n        page,\n        totalPages: mock.length / perPage,\n      });\n    }, timeout);\n  });\n};\n","import React, { useState, useEffect, useRef } from \"react\";\nimport useIsElementVisible from \"./hooks/useIsElementVisible\";\nimport { fetchTodos } from \"./services\";\n\nexport default function App() {\n  const lastRef = useRef(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [todos, setTodos] = useState({\n    itens: [],\n    page: 0,\n    totalPages: 1,\n  });\n  const isLastVisible = useIsElementVisible(lastRef.current);\n\n  useEffect(() => {\n    getMoreTodos(todos.page + 1);\n  }, []);\n\n  useEffect(() => {\n    if (isLastVisible) {\n      getMoreTodos(todos.page + 1);\n    }\n  }, [isLastVisible]);\n\n  const getMoreTodos = async (page) => {\n    try {\n      setIsLoading(true);\n      const newTodos = await fetchTodos(page);\n      setTodos((prev) => ({\n        ...newTodos,\n        itens: prev.itens.concat(newTodos.itens),\n      }));\n      setIsLoading(false);\n    } catch (err) {}\n  };\n\n  return (\n    <div className=\"container\">\n      <h2 className=\"title\">Lorem ipsum's list</h2>\n      {todos.itens.map(({ title }, index) => {\n        return (\n          <div className=\"card-box\" key={index}>\n            <p>{title}</p>\n          </div>\n        );\n      })}\n      {!!todos.itens.length && todos.page < todos.totalPages && (\n        <div ref={lastRef} />\n      )}\n      {isLoading && <p className=\"loading\">Loading...</p>}\n    </div>\n  );\n}\n","import { useEffect, useState } from \"react\";\n\nexport default (el) => {\n  const [isVisible, setIsVisible] = useState(false);\n  const callback = ([entry]) => {\n    setIsVisible(entry.isIntersecting);\n  };\n\n  useEffect(() => {\n    const watch = new IntersectionObserver(callback);\n    if (el) {\n      watch.observe(el);\n      return () => watch.unobserve(el);\n    }\n  }, [el]);\n\n  return isVisible && !!el;\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}